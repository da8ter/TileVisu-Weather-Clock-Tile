<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
    <script src="/icons.js" crossorigin="anonymous"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>BBC Weather Image</title>
  <style id="flipclock-css"></style>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      color: #fff;
    }
    #wrap {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #000;
      background-size: cover;
      background-position: center bottom;
      background-repeat: no-repeat;
      isolation: isolate;
      z-index: 1001;
      will-change: background-image;
    }

    #wrap::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 35%;
      background: inherit;
      background-size: inherit;
      background-position: inherit;
      background-repeat: inherit;
      pointer-events: none;
      z-index: 1;
      -webkit-filter: blur(5px);
      filter: blur(5px);
      /* Fallback for older WebKit */
      -webkit-mask-image: -webkit-gradient(linear, left top, right top, from(#fff), to(rgba(255, 255, 255, 0)));
      -webkit-mask-image: linear-gradient(to right, #fff, rgba(255, 255, 255, 0));
      mask-image: linear-gradient(to right, #fff, rgba(255, 255, 255, 0));
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
      -webkit-mask-position: left center;
      mask-position: left center;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      will-change: filter;
      contain: paint;
    }

    #wrap::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 35%;
      background: linear-gradient(in oklch to right, rgb(10 25 70 / 0.7), rgb(10 25 70 / 0));
      pointer-events: none;
      z-index: 1;
    }

    /* Wrap-level overlays are disabled; overlays now live on .bg-layer */
    #wrap::before,
    #wrap::after {
      content: none !important;
    }

    .bg-layer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #000;
      background-size: cover;
      background-position: center bottom;
      background-repeat: no-repeat;
      opacity: 0;
      transition: opacity 0ms ease;
      z-index: 0;
      pointer-events: none;
      will-change: opacity, background-image;
    }
    .bg-layer.is-active { opacity: 1; }

    .bg-layer::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 35%;
      background: inherit;
      background-size: inherit;
      background-position: inherit;
      background-repeat: inherit;
      pointer-events: none;
      z-index: 1;
      -webkit-filter: blur(5px);
      filter: blur(5px);
      -webkit-mask-image: -webkit-gradient(linear, left top, right top, from(#fff), to(rgba(255, 255, 255, 0)));
      -webkit-mask-image: linear-gradient(to right, #fff, rgba(255, 255, 255, 0));
      mask-image: linear-gradient(to right, #fff, rgba(255, 255, 255, 0));
      -webkit-mask-size: 100% 100%;
      mask-size: 100% 100%;
      -webkit-mask-position: left center;
      mask-position: left center;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      will-change: filter;
      contain: paint;
    }

    .bg-layer::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 35%;
      background: linear-gradient(in oklch to right, rgb(10 25 70 / 0.7), rgb(10 25 70 / 0));
      pointer-events: none;
      z-index: 1;
    }

    /* Hide blur/gradient when weather is disabled */
    body.no-weather #wrap::before,
    body.no-weather #wrap::after,
    body.no-weather .bg-layer::before,
    body.no-weather .bg-layer::after {
      content: none !important;
    }

    #temperature {
      position: absolute;
      top: 60%;
      left: 1vw;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.1rem;
      color: inherit;
      font-size: 45px;
      z-index: 2;
    }

    #temperature-icon {
      display: inline-flex;
      align-items: center;
      justify-content: flex-start;
      min-width: 8.8rem;
      min-height: 1.8rem;
    }

    #temperature-icon img {
      max-width: 4.4rem;
      max-height: 4.4rem;
      display: block;
    }

    #temperature-icon i[class^="fa-"],
    #temperature-icon i[class*=" fa-"] {
      font-size: 1.2em;
      line-height: 1;
    }

    #temperature-value { font-size: 45px; line-height: 1; }
    #temperature-extra {
      display: flex;
      flex-direction: row;
      align-items: baseline;
      gap: 0.3rem;
      margin-top: 0.2rem;
      white-space: nowrap;
    }
    #temperature-day { font-size: 16px; opacity: 0.9; }
    #temperature-minmax { font-size: 18px; opacity: 0.9; }
    /* Bottom-left stack for temperature + forecast */
    #left-stack {
      position: absolute;
      left: 1vw;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.6rem; /* spacing between temperature and forecast */
      z-index: 2;
      color: inherit;
      transform-origin: bottom left;
    }
    /* Forecast strip */
    #forecast {
      display: flex;
      gap: 0.0rem;
      align-items: stretch;
      color: inherit;
      opacity: 0.7; /* 30% transparent */
    }
    /* Reset temperature positioning inside left-stack */
    #left-stack #temperature {
      position: static;
      top: auto;
      left: auto;
      transform: none;
      opacity: 1;
      padding-left: 0.6rem; /* align with .forecast-item horizontal padding */
    }
    .forecast-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 0.4rem 0.6rem;
      border-radius: 6px;
      min-width: 50px;
      backdrop-filter: blur(0px);
    }
    .forecast-item .fi-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(1.2rem, 2.4vw, 1.6rem);
      margin-bottom: 0.2rem;
    }
    .forecast-item .fi-icon img {
      width: 1.5em;
      height: 1.5em;
      display: block;
    }
    .forecast-item .fi-label {
      font-size: 14px;
      margin-bottom: 0.15rem;
      white-space: nowrap;
    }
    .forecast-item .fi-temps {
      font-size: 17px;
      white-space: nowrap;
    }
    #clock-wrapper {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
      max-width: 100vw;
      max-height: 50vh;
      overflow: visible;
      z-index: 2;
    }
    #clock {
      display: inline-block;
      transform-origin: center top;
      /* Let JS cap the width via font-size; do not clip */
      overflow: visible;
    }
    #clock .flip-clock {
      margin: 0;
      /* Persist exact sizing via CSS variables set on #clock container */
      width: var(--clock-width-px, auto);
      min-width: var(--clock-width-px, auto);
      max-width: var(--clock-width-px, none);
      /* Base size from backend percent; can be overridden by --clock-font-px */
      font-size: var(--clock-font-px, clamp(10px, calc(var(--clock-pct, 70vw) / 18.5), 200px));
      font-variant-numeric: tabular-nums;
      font-feature-settings: 'tnum' 1;
      overflow: visible;
    }
    #clock-wrapper .flip-clock {
      float: none !important;
      display: inline-flex;
      justify-content: center;
    }
    #clock .flip-clock ul {
      background: rgba(0, 0, 0, 0.6);
      border-radius: 6px;
    }
    #clock .flip-clock-divider .flip-clock-label {
      display: none;
    }
    #clock .flip-clock-divider {
      position: relative;
      z-index: 3;
      display: inline-block;
      min-width: 0.6em;
      /* Keep minimum horizontal gap to hours/minutes */
      margin-left: clamp(2px, 0.15em, 8px);
      margin-right: clamp(2px, 0.15em, 8px);
      /* Do not shrink in flex layout */
      flex: 0 0 auto;
      align-self: center;
    }
    #clock .flip-clock-divider .flip-clock-dot {
      opacity: 1 !important;
      visibility: visible !important;
    }
    #date {
      /* Cap size while remaining responsive; backend can override via dateFontSizePx */
      font-size: clamp(12px, 2.4vw, 50px);
      font-weight: 500;
      letter-spacing: 0.04em;
      text-align: center;
      color: inherit;
      margin-top: 10px;
      display: block;
      width: 100%;
      /* prevent line breaks */
      white-space: nowrap;
      overflow: visible;
      text-overflow: ellipsis;
    }
    #error {
      position: absolute;
      top: 0; left: 0; right: 0;
      padding: 8px 12px;
      background: rgba(200,0,0,0.2);
      color: #fff;
      font-size: 14px;
      display: none;
    }
#clock .flip-clock-list .flip-clock-list-item-inner .top:before { bottom: -0px; }
#clock .flip-clock-list .flip-clock-list-item-inner .bottom:before { top: -1px; }
    .show-error #error { display: block; }
  </style>
  <script>
    // Global variables for clock functionality
    let flipClock = null;
    let clockSyncTimer = null;
    let resizeClockFrame = null;
    let leftStackScaleFrame = null;
    let resizeDebounceTimer = null;
    // Backend-configurable percentages (defaults)
    let forecastWidthPercent = 25; // % of window width
    let clockWidthPercent = 70;    // % of window width
    let dateFontSizePx = 0;        // 0 = use CSS default
    let dateScaleFactor = 1;       // 1..5 factor for date size relative to clock
    let clockVerticalPercent = 50;
    let suppressNonWindowResize = true;
    let inWindowResize = false;
    let initialClockLayoutDone = false;
    // Track last visibility flags to avoid unnecessary resizes on frequent payloads
    let lastShowWeather = null;
    let lastShowClock = null;
    let lastShowDate = null;
    let lastShowForecast = null;
    let webhookToken = "";
    let showSeconds = false;
    let lastShowSeconds = null;
    

    function injectStyle(targetId, base64) {
      const styleEl = document.getElementById(targetId);
      if (!styleEl) {
        return;
      }
      styleEl.textContent = atob(base64);
    }

    function injectScript(base64) {
      const script = document.createElement('script');
      script.type = 'text/javascript';
      script.text = atob(base64);
      document.head.appendChild(script);
    }

    // FlipClock Assets via WebHook (no CDN). We'll inject when first image URL arrives
    let flipClockAssetsRequested = false;
    function ensureFlipClockAssetsFromUrl(imageUrl, ts) {
      try {
        if (flipClockAssetsRequested) return;
        const raw = (typeof imageUrl === 'string') ? imageUrl : '';
        if (!raw) return;
        let base = raw.split('?')[0] || '';
        let token = webhookToken || '';
        try {
          const u = new URL(raw, window.location.origin);
          base = u.pathname || base || raw;
          if (!token) token = u.searchParams.get('token') || '';
        } catch (_) {}
        if (!base) return;
        const v = (typeof ts === 'number' && isFinite(ts)) ? ts : Date.now();
        const tpart = token ? ('token=' + encodeURIComponent(token) + '&') : '';
        const cssUrl = base + '?' + tpart + 'asset=flipclock.min.css&v=' + v;
        const jsUrl  = base + '?' + tpart + 'asset=flipclock.min.js&v=' + v;
        // CSS
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = cssUrl;
        link.onload = () => {};
        document.head.appendChild(link);
        // JS
        const s = document.createElement('script');
        s.src = jsUrl;
        s.async = true;
        s.onload = () => {};
        document.head.appendChild(s);
        flipClockAssetsRequested = true;
      } catch (e) { console.error(e); }
    }

    function ensureFlipClockAssetsFromBase(base, ts) {
      try {
        if (flipClockAssetsRequested) return;
        if (!base || typeof base !== 'string') return;
        const clean = base.split('?')[0];
        if (!clean) return;
        const v = (typeof ts === 'number' && isFinite(ts)) ? ts : Date.now();
        const token = webhookToken || '';
        const tpart = token ? ('token=' + encodeURIComponent(token) + '&') : '';
        const cssUrl = clean + '?' + tpart + 'asset=flipclock.min.css&v=' + v;
        const jsUrl  = clean + '?' + tpart + 'asset=flipclock.min.js&v=' + v;
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = cssUrl;
        link.onload = () => {};
        document.head.appendChild(link);
        const s = document.createElement('script');
        s.src = jsUrl;
        s.async = true;
        s.onload = () => {};
        document.head.appendChild(s);
        flipClockAssetsRequested = true;
      } catch (e) { console.error(e); }
    }

    // Bilder werden ausschließlich per WebHook-URL geladen

    function tryLoadSequential(urls, onSuccess, onFailure) {
      let idx = 0;
      const next = () => {
        if (!Array.isArray(urls) || idx >= urls.length) {
          if (typeof onFailure === 'function') onFailure();
          return;
        }
        const u = urls[idx++];
        const img = new Image();
        img.onload = () => { if (typeof onSuccess === 'function') onSuccess(u); };
        img.onerror = next;
        img.src = u;
      };
      next();
    }

    function setImage(url, slug, tod, ts) {
      const wrap = document.getElementById('wrap');
      if (!wrap) return;
      // Cache-Busting helper
      const withTs = (u, t) => {
        const sep = u.includes('?') ? '&' : '?';
        return u + sep + 'v=' + (t || Date.now());
      };
      const bgA = document.getElementById('bgA');
      const bgB = document.getElementById('bgB');
      if (!url || typeof url !== 'string' || url.trim() === '') {
        showError('Kein Bild verfügbar');
        return;
      }
      const finalUrl = withTs(url.trim(), ts);
      const active = (bgA && bgA.classList.contains('is-active')) ? bgA : bgB;
      const next = active === bgA ? bgB : bgA;
      if (!active || !next) {
        // Fallback: set on wrap directly
        wrap.style.backgroundImage = `url('${finalUrl}')`;
        wrap.setAttribute('data-image-info', ((slug || '') + ' ' + (tod || '')).trim());
        updateDate();
        document.body.classList.remove('show-error');
        return;
      }
      // Preload and crossfade
      try {
        const img = new Image();
        img.onload = () => {
          next.style.backgroundImage = `url('${finalUrl}')`;
          next.classList.add('is-active');
          active.classList.remove('is-active');
          wrap.setAttribute('data-image-info', ((slug || '') + ' ' + (tod || '')).trim());
          updateDate();
          document.body.classList.remove('show-error');
        };
        img.onerror = () => showError('Kein Bild verfügbar');
        img.src = finalUrl;
      } catch (_) {
        showError('Kein Bild verfügbar');
      }
    }

    function clearImage() {
      const bgA = document.getElementById('bgA');
      const bgB = document.getElementById('bgB');
      if (bgA && bgB) {
        bgA.style.backgroundImage = 'none';
        bgB.style.backgroundImage = 'none';
        bgA.classList.add('is-active');
        bgB.classList.remove('is-active');
      }
      const wrap = document.getElementById('wrap');
      if (wrap) {
        wrap.style.backgroundImage = 'none';
        wrap.removeAttribute('data-image-info');
      }
      document.body.classList.remove('show-error');
    }

    function showError(msg) {
      // Suppress error UI if weather is intentionally disabled
      if (document && document.body && document.body.classList.contains('no-weather')) {
        clearImage();
        return;
      }
      const el = document.getElementById('error');
      el.textContent = msg || 'Unbekannter Fehler';
      document.body.classList.add('show-error');
      const wrap = document.getElementById('wrap');
      if (wrap) {
        wrap.style.backgroundImage = 'none';
      }
    }

    // Clock variables are now declared at the top of the script

    function initClock() {
      // Wait until FlipClock.js (modern) is loaded by the loader
      if (typeof window.FlipClock === 'undefined') {
        setTimeout(initClock, 300);
        return;
      }
      if (flipClock) {
        if (clockSyncTimer) {
          clearTimeout(clockSyncTimer);
          clockSyncTimer = null;
        }
        return;
      }

      const el = document.getElementById('clock');
      if (!el) {
        return;
      }

      try {
        // Instantiate new FlipClock with a 24h clock face and no seconds
        // In v0.10.8, pass the face as a string key ("TwentyFourHourClock")
        flipClock = new window.FlipClock(el, new Date(), {
          face: 'TwentyFourHourClock',
          showSeconds: !!showSeconds
        });
        // Drive clock ourselves to avoid relying on internal timer
        updateDate();
        const syncClock = () => {
          const now = updateClockTime();
          const msToNextSecond = 1000 - now.getMilliseconds();
          clockSyncTimer = setTimeout(syncClock, msToNextSecond);
        };
        clockSyncTimer = setTimeout(syncClock, 1000 - (new Date()).getMilliseconds());
      } catch (e) {
        console.error(e);
      }
    }

    function destroyClock() {
      try { if (clockSyncTimer) { clearTimeout(clockSyncTimer); } } catch (_) {}
      clockSyncTimer = null;
      flipClock = null;
      try {
        const el = document.getElementById('clock');
        if (el) { el.innerHTML = ''; }
      } catch (_) {}
    }

    function recreateClock() {
      destroyClock();
      initClock();
    }

    function updateClockTime() {
      const now = new Date();
      if (flipClock) {
        try { flipClock.value = now; } catch (_) {}
      }
      return now;
    }

    function currentSecondsOfDay(now = new Date()) {
      // Use local time components
      return now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
    }

    function scheduleResizeClock(opts) {
      try { opts = opts || {}; } catch (_) { opts = {}; }
      const force = !!(opts && opts.force);
      if (suppressNonWindowResize && !inWindowResize && !force && initialClockLayoutDone) {
        return;
      }
      if (resizeClockFrame) {
        cancelAnimationFrame(resizeClockFrame);
      }
      resizeClockFrame = requestAnimationFrame(() => {
        resizeClockFrame = null;
        resizeClock();
      });
    }

    // Observers removed: sizing persists via CSS variables on #clock container
    // Resize only on window resize or backend changes

    function scheduleLeftStackScale() {
      if (leftStackScaleFrame) {
        cancelAnimationFrame(leftStackScaleFrame);
      }
      leftStackScaleFrame = requestAnimationFrame(() => {
        leftStackScaleFrame = null;
        scaleLeftStack();
      });
    }

    // Sichtbarkeit von Wetter (left-stack), Uhr (clock-wrapper), Datum (#date) und Forecast (#forecast) steuern
    function applyVisibility(showWeather, showClock, showDate, showForecast) {
      try {
        const leftStack = document.getElementById('left-stack');
        const clockWrap = document.getElementById('clock-wrapper');
        const dateEl = document.getElementById('date');
        const forecastEl = document.getElementById('forecast');
        const temperatureEl = document.getElementById('temperature');
        if (document && document.body) {
          document.body.classList.toggle('no-weather', !showWeather);
        }
        if (leftStack) {
          leftStack.style.display = showWeather ? '' : 'none';
        }
        if (clockWrap) {
          clockWrap.style.display = showClock ? '' : 'none';
        }
        if (dateEl) {
          const sd = (typeof showDate === 'boolean') ? showDate : true;
          dateEl.style.display = sd ? '' : 'none';
        }
        if (forecastEl) {
          const sf = (typeof showForecast === 'boolean') ? showForecast : true;
          forecastEl.style.display = sf ? '' : 'none';
        }
        if (temperatureEl) {
          const sf = (typeof showForecast === 'boolean') ? showForecast : true;
          temperatureEl.style.display = sf ? '' : 'none';
        }
      } catch (e) { /* noop */ }
    }

    function applyDateFontSize() {
      try {
        const dateEl = document.getElementById('date');
        if (!dateEl) return;
        const px = (typeof dateFontSizePx === 'number' && isFinite(dateFontSizePx)) ? dateFontSizePx : 0;
        if (px > 0) {
          dateEl.style.fontSize = `${px}px`;
        } else {
          dateEl.style.fontSize = '';
        }
      } catch (_) {}
    }

    function applyClockVertical() {
      try {
        const cw = document.getElementById('clock-wrapper');
        if (!cw) return;
        const v = (typeof clockVerticalPercent === 'number' && isFinite(clockVerticalPercent)) ? clockVerticalPercent : 50;
        const vv = Math.max(0, Math.min(100, Math.round(v)));
        cw.style.top = vv + '%';
      } catch (_) {}
    }

    function scaleLeftStack() {
      const stack = document.getElementById('left-stack');
      if (!stack) {
        return;
      }

      stack.style.transform = '';
      stack.style.maxWidth = '';

      const percent = (typeof forecastWidthPercent === 'number' && isFinite(forecastWidthPercent)) ? forecastWidthPercent : 25;
      const cfgWidth = window.innerWidth * (Math.max(5, Math.min(100, percent)) / 100);
      if (!Number.isFinite(cfgWidth) || cfgWidth <= 0) {
        return;
      }

      // Use #temperature as the collision base (fallback to stack if missing)
      const tempEl = document.getElementById('temperature');
      const baseEl = tempEl || stack;
      const baseRect = baseEl.getBoundingClientRect();
      if (!baseRect.width) {
        return;
      }

      // Horizontal-only: measure free space until the actual flip-clock's left edge
      const clockWrap = document.getElementById('clock-wrapper');
      const flip = document.querySelector('#clock .flip-clock');
      const gap = 15; // px spacing
      let availableToClock = Infinity;
      let clockVisible = false;
      const measureEl = flip || clockWrap || null;
      if (measureEl) {
        const cs = window.getComputedStyle(measureEl);
        clockVisible = cs && cs.display !== 'none' && cs.visibility !== 'hidden';
      }
      if (clockVisible && measureEl) {
        const clockRect = measureEl.getBoundingClientRect();
        availableToClock = Math.max(0, clockRect.left - gap - baseRect.left);
      }
      // Compute scales:
      // - cfgScale limits overall left-stack width to backend percent
      // - freeScale uses temperature width to fill space until the clock
      const stackRect = stack.getBoundingClientRect();
      if (!stackRect.width) {
        return;
      }
      const minScale = 0.5;
      const cfgScaleRaw = cfgWidth / stackRect.width;
      const cfgScale = Number.isFinite(cfgScaleRaw) && cfgScaleRaw > 0 ? cfgScaleRaw : 1;
      const freeScaleRaw = (!clockVisible || !Number.isFinite(availableToClock)) ? Infinity : (availableToClock / baseRect.width);
      const freeScale = Number.isFinite(freeScaleRaw) && freeScaleRaw > 0 ? freeScaleRaw : Infinity;
      let scale = Math.min(cfgScale, freeScale);
      if (!Number.isFinite(scale) || scale <= 0) scale = 1;
      scale = Math.max(minScale, scale);
      stack.style.transform = `scale(${scale})`;
      // Do not constrain with maxWidth; transform defines the visual width
      stack.style.maxWidth = '';
    }

    function resizeClock() {
      const container = document.getElementById('clock-wrapper');
      const clockContainer = document.getElementById('clock');
      let clockEl = null;
      if (clockContainer) {
        if (clockContainer.classList.contains('flip-clock')) {
          clockEl = clockContainer;
        } else {
          clockEl = clockContainer.querySelector('.flip-clock');
        }
      }
      if (!container || !clockContainer || !clockEl) {
        if (!container || !clockContainer) {
          return;
        }
        requestAnimationFrame(resizeClock);
        return;
      }
      const dateEl = document.getElementById('date');
      if (dateEl) {
        if (dateEl.parentElement !== container) {
          container.appendChild(dateEl);
        } else if (container.lastElementChild !== dateEl) {
          container.appendChild(dateEl);
        }
      }
      console.log('resizeClock: start');
      // Reset any transform-based scaling and let CSS handle size
      clockContainer.style.transform = 'none';
      clockContainer.style.height = '';
      clockContainer.style.width = '';
      // Set CSS variable based on backend percent so width ≈ pct vw
      const pct = (typeof clockWidthPercent === 'number' && isFinite(clockWidthPercent))
        ? Math.max(5, Math.min(100, clockWidthPercent))
        : 70;
      clockContainer.style.setProperty('--clock-pct', pct + 'vw');
      // No margin side-effects
      clockContainer.style.marginBottom = '0';
      // Calculate target width once for both clock and date sizing
      const targetWidth = Math.max(0, Math.floor(window.innerWidth * (pct / 100)));

      // Observers disabled: CSS variables persist sizing
      // Lock exact width now: set inline font-size so width == target
      try {
        const rect = clockEl.getBoundingClientRect();
        const computed = window.getComputedStyle(clockEl);
        const fontPx = parseFloat(computed.fontSize) || 16;
        if (rect.width && targetWidth) {
          const newFontPx = Math.max(8, Math.min(400, fontPx * (targetWidth / rect.width)));
          // Clear any prior inline styles on the flip element; rely on container CSS variables
          try {
            clockEl.style.fontSize = '';
            clockEl.style.width = '';
            clockEl.style.minWidth = '';
            clockEl.style.maxWidth = '';
          } catch (_) {}
          // Persist sizing to #clock container so replacements inherit immediately
          clockContainer.style.setProperty('--clock-font-px', `${newFontPx}px`);
          clockContainer.style.setProperty('--clock-width-px', `${targetWidth}px`);
        }
      } catch (_) {}
      // Size the date based on targetWidth, unless backend override is set
      try {
        const dateEl = document.getElementById('date');
        const pxOverride = (typeof dateFontSizePx === 'number' && isFinite(dateFontSizePx) && dateFontSizePx > 0) ? dateFontSizePx : 0;
        if (dateEl && !pxOverride) {
          // Compute from final clock font size: (clockPx / 3) * dateScaleFactor (1..5)
          const finalClockPx = parseFloat(window.getComputedStyle(clockEl).fontSize) || 16;
          const factor = (typeof dateScaleFactor === 'number' && isFinite(dateScaleFactor)) ? Math.max(1, Math.min(5, dateScaleFactor)) : 1;
          const datePx = Math.max(10, Math.round((finalClockPx / 3) * factor));
          dateEl.style.fontSize = `${datePx}px`;
          dateEl.style.whiteSpace = 'nowrap';
          dateEl.style.textOverflow = 'ellipsis';
        }
      } catch (_) {}
      // Re-scale left stack now that clock size is final
      try { scheduleLeftStackScale(); } catch (_) {}
      initialClockLayoutDone = true;
    }

    function updateDate() {
      console.log('Updating date...');
      const dateEl = document.getElementById('date');
      if (!dateEl) {
        return;
      }
      try {
        const formatter = new Intl.DateTimeFormat('de-DE', {
          day: '2-digit',
          month: 'long',
          year: 'numeric'
        });
        const formattedDate = formatter.format(new Date());
        dateEl.textContent = formattedDate;
      } catch (e) {
        // Fallback to simple date format
        dateEl.textContent = new Date().toLocaleDateString('de-DE');
      }
    }

    // Wird vom Modul via UpdateVisualizationValue(data) aufgerufen
    function handleMessage(data) {
      try {
        if (!data) return;
        // Falls data ein JSON-String ist, parse ihn
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch (parseError) {
            showError('Ungültiges JSON vom Modul: ' + data.substring(0, 100));
            return;
          }
        }

        // Capture token early for subsequent asset loads
        try {
          if (data && typeof data.token === 'string' && data.token.trim()) {
            webhookToken = data.token.trim();
          }
        } catch (_) {}

        // Toggle visibility if flags are present
        if (typeof data.showWeather === 'boolean' || typeof data.showClock === 'boolean' || typeof data.showDate === 'boolean' || typeof data.showForecast === 'boolean' || typeof data.showSeconds === 'boolean') {
          const sw = (typeof data.showWeather === 'boolean') ? data.showWeather : (lastShowWeather === null ? true : lastShowWeather);
          const sc = (typeof data.showClock === 'boolean') ? data.showClock : (lastShowClock === null ? true : lastShowClock);
          const sd = (typeof data.showDate === 'boolean') ? data.showDate : (lastShowDate === null ? true : lastShowDate);
          const sf = (typeof data.showForecast === 'boolean') ? data.showForecast : (lastShowForecast === null ? true : lastShowForecast);
          const ss = (typeof data.showSeconds === 'boolean') ? data.showSeconds : (lastShowSeconds === null ? false : lastShowSeconds);
          const prevSW = lastShowWeather;
          const prevSC = lastShowClock;
          const prevSD = lastShowDate;
          const prevSF = lastShowForecast;
          const prevSS = lastShowSeconds;
          applyVisibility(!!sw, !!sc, !!sd, !!sf);
          lastShowWeather = !!sw;
          lastShowClock = !!sc;
          lastShowDate = !!sd;
          lastShowForecast = !!sf;
          if (prevSS === null || prevSS !== !!ss) {
            showSeconds = !!ss;
            lastShowSeconds = !!ss;
            recreateClock();
          }
          const flagsChanged = (prevSW === null || prevSC === null || prevSD === null || prevSF === null)
            ? true
            : (prevSW !== lastShowWeather || prevSC !== lastShowClock || prevSD !== lastShowDate || prevSF !== lastShowForecast);
          if (flagsChanged) {
            if (lastShowClock) {
              scheduleResizeClock({ force: true });
            }
            if (lastShowWeather) {
              scheduleLeftStackScale();
            }
          }
        }

        // Read optional width configuration (clamp to 5..100)
        if (typeof data.forecastWidthPercent === 'number' && isFinite(data.forecastWidthPercent)) {
          const v = Math.max(5, Math.min(100, Math.round(data.forecastWidthPercent)));
          if (v !== forecastWidthPercent) {
            forecastWidthPercent = v;
            scheduleLeftStackScale();
            scheduleResizeClock({ force: true });
          }
        }
        if (typeof data.clockWidthPercent === 'number' && isFinite(data.clockWidthPercent)) {
          const v = Math.max(5, Math.min(100, Math.round(data.clockWidthPercent)));
          if (v !== clockWidthPercent) {
            clockWidthPercent = v;
            scheduleResizeClock({ force: true });
          }
        }
        // Read optional date font size (px); 0 keeps CSS default
        if (typeof data.dateFontSizePx === 'number' && isFinite(data.dateFontSizePx)) {
          const v = Math.max(0, Math.min(200, Math.round(data.dateFontSizePx)));
          if (v !== dateFontSizePx) {
            dateFontSizePx = v;
            applyDateFontSize();
            scheduleResizeClock({ force: true });
          }
        }
        // Read optional date scale factor (1..5); used when no px override
        if (typeof data.dateScaleFactor === 'number' && isFinite(data.dateScaleFactor)) {
          const v = Math.max(1, Math.min(5, Math.round(data.dateScaleFactor)));
          if (v !== dateScaleFactor) {
            dateScaleFactor = v;
            scheduleResizeClock({ force: true });
          }
        }

        if (typeof data.clockVerticalPercent === 'number' && isFinite(data.clockVerticalPercent)) {
          const v = Math.max(0, Math.min(100, Math.round(data.clockVerticalPercent)));
          if (v !== clockVerticalPercent) {
            clockVerticalPercent = v;
            applyClockVertical();
            scheduleResizeClock({ force: true });
          }
        }

        switch (data.type) {
          case 'image':
            {
              try {
                const code = (typeof data.wmoCode !== 'undefined') ? data.wmoCode : null;
                const imgName = (typeof data.imageName === 'string') ? data.imageName : '';
                console.debug('TileVisu Weather: WMO code =', code, 'Bildname =', imgName);
              } catch (e) {}
              const sw = (typeof data.showWeather === 'boolean') ? data.showWeather : true;
              const url = (typeof data.url === 'string') ? data.url.trim() : '';
              if (url) {
                setImage(url, data.slug || '', data.timeOfDay || '', data.ts || 0);
                // Ensure FlipClock assets are loaded via the same WebHook base (cache-busted)
                ensureFlipClockAssetsFromUrl(url, data.ts || Date.now());
                if (typeof data.assetBase === 'string' && data.assetBase.trim()) {
                  ensureFlipClockAssetsFromBase(data.assetBase.trim(), data.ts || Date.now());
                }
              } else if (!sw) {
                clearImage();
                if (typeof data.assetBase === 'string' && data.assetBase.trim()) {
                  ensureFlipClockAssetsFromBase(data.assetBase.trim(), data.ts || Date.now());
                }
              } else {
                showError('Kein Bild verfügbar');
                if (typeof data.assetBase === 'string' && data.assetBase.trim()) {
                  ensureFlipClockAssetsFromBase(data.assetBase.trim(), data.ts || Date.now());
                }
              }
            }
            if (Array.isArray(data.forecast)) {
              applyFirstDayToTemperature(data.forecast[0] || null);
              renderForecast(data.forecast);
            }
            if (data.temperature) {
              updateTemperature(data.temperature);
            }
            // Only force resize on initial layout; after that, avoid periodic forced resizes
            if (!initialClockLayoutDone) {
              scheduleResizeClock({ force: true });
            } else {
              scheduleResizeClock();
            }
            scheduleLeftStackScale();
            break;
          case 'temperature':
            updateTemperature(data.temperature || {});
            scheduleLeftStackScale();
            break;
          case 'forecast':
            applyFirstDayToTemperature((data.forecast || [])[0] || null);
            renderForecast(data.forecast || []);
            scheduleLeftStackScale();
            break;
        }
      } catch (e) {
        console.error(e);
        showError('Fehler beim Verarbeiten der Nachricht');
      }
    }

    // Bridge: IP-Symcon HTML-SDK ruft diese Funktion mit dem JSON-String auf
    function UpdateVisualizationValue(data) {
      try {
        handleMessage(data);
      } catch (e) {
        console.error(e);
        try { showError('Fehler beim Aktualisieren der Visualisierung'); } catch (_) {}
      }
    }

    function shortenDayName(label) {
      try {
        const map = {
          'Montag': 'Mo', 'Dienstag': 'Di', 'Mittwoch': 'Mi', 'Donnerstag': 'Do', 'Freitag': 'Fr', 'Samstag': 'Sa', 'Sonntag': 'So'
        };
        return map[label] || (label ? label.slice(0, 2) : '');
      } catch (_) { return label || ''; }
    }

    function renderForecast(forecast) {
      const cont = document.getElementById('forecast');
      if (!cont) return;
      if (!Array.isArray(forecast)) forecast = [];
      cont.innerHTML = '';
      const start = 1; // skip first day (used with temperature)
      const maxItems = Math.min(3, Math.max(0, forecast.length - start));
      for (let k = 0; k < maxItems; k++) {
        const i = start + k;
        const d = forecast[i] || {};
        const item = document.createElement('div');
        item.className = 'forecast-item';

        const iconWrap = document.createElement('div');
        iconWrap.className = 'fi-icon';
        const iconUrl = (typeof d.iconUrl === 'string' && d.iconUrl.trim()) ? d.iconUrl.trim() : '';
        if (iconUrl) {
          const img = document.createElement('img');
          img.src = iconUrl;
          img.alt = '';
          iconWrap.appendChild(img);
        } else {
          const iTag = document.createElement('i');
          const iconClasses = typeof d.icon === 'string' && d.icon.trim() ? d.icon.trim() : '';
          if (iconClasses) {
            iconClasses.split(/\s+/).forEach(cls => iTag.classList.add(cls));
          }
          iconWrap.appendChild(iTag);
        }

        const temps = document.createElement('div');
        temps.className = 'fi-temps';
        const maxVal = (typeof d.max === 'number') ? d.max : null;
        const minVal = (typeof d.min === 'number') ? d.min : null;
        const dayName = shortenDayName(d.label || '');
        let tempStr = '';
        if (maxVal !== null && minVal !== null) {
          const lo = Math.min(minVal, maxVal);
          const hi = Math.max(minVal, maxVal);
          tempStr = `${lo}° - ${hi}°`;
        } else if (maxVal !== null) {
          tempStr = `${maxVal}°`;
        } else if (minVal !== null) {
          tempStr = `${minVal}°`;
        }
        temps.textContent = dayName ? `${dayName} ${tempStr}` : tempStr;

        item.appendChild(iconWrap);
        item.appendChild(temps);
        cont.appendChild(item);
      }

      scheduleLeftStackScale();
    }

    // bottom-aligned forecast via CSS; no dynamic positioning needed

    function prepareIconForDisplay(iconName) {
      if (!iconName || iconName === 'Transparent') {
        return null;
      }

      const STYLE_ALIASES = {
        fas: 'fa-solid',
        far: 'fa-regular',
        fal: 'fa-light',
        fat: 'fa-thin',
        fad: 'fa-duotone',
        fab: 'fa-brands',
        fak: 'fa-kit',
        fa: 'fa-light'
      };

      const KNOWN_STYLES = new Set([
        'fa-solid',
        'fa-regular',
        'fa-light',
        'fa-thin',
        'fa-duotone',
        'fa-brands',
        'fa-kit',
        'fa-sharp'
      ]);

      const tokens = iconName.trim().split(/\s+/).filter(Boolean);
      if (tokens.length === 0) {
        return null;
      }

      const classes = new Set(['fa-fw']);
      let slugClass = '';

      for (const token of tokens) {
        const lower = token.toLowerCase();

        if (lower === 'fa-fw') {
          classes.add('fa-fw');
          continue;
        }

        if (STYLE_ALIASES[lower]) {
          classes.add(STYLE_ALIASES[lower]);
          continue;
        }

        if (KNOWN_STYLES.has(lower)) {
          classes.add(lower);
          continue;
        }

        if (lower.startsWith('fa-')) {
          if (KNOWN_STYLES.has(lower)) {
            classes.add(lower);
          } else {
            slugClass = lower;
          }
          continue;
        }

        slugClass = `fa-${lower}`;
      }

      if (!slugClass) {
        const base = tokens[tokens.length - 1].toLowerCase();
        slugClass = base.startsWith('fa-') ? base : `fa-${base}`;
      }

      // Force Font Awesome "light" style regardless of incoming style tokens
      [...classes].forEach((c) => {
        if (KNOWN_STYLES.has(c)) {
          classes.delete(c);
        }
      });
      classes.add('fa-light');

      classes.add(slugClass);

      return Array.from(classes).join(' ');
    }

    function updateTemperature(tempData = {}) {
      const valueEl = document.getElementById('temperature-value');
      if (!valueEl) {
        return;
      }

      const valueText = typeof tempData.value === 'string' ? tempData.value : '';
      valueEl.textContent = valueText;

      const wrapper = document.getElementById('temperature');
      if (wrapper) {
        wrapper.classList.toggle('is-hidden', valueText === '');
      }

      const iconUrl = (typeof tempData.iconUrl === 'string' && tempData.iconUrl.trim()) ? tempData.iconUrl.trim() : '';
      const iconEl = document.getElementById('temperature-icon');
      if (iconEl && iconUrl) {
        iconEl.classList.remove('has-icon', 'has-image');
        iconEl.innerHTML = '';
        const img = document.createElement('img');
        img.src = iconUrl;
        img.alt = '';
        iconEl.appendChild(img);
        iconEl.classList.add('has-image');
      }

      scheduleLeftStackScale();
    }

    function applyFirstDayToTemperature(day) {
      const iconEl = document.getElementById('temperature-icon');
      const dayEl = document.getElementById('temperature-day');
      const mmEl = document.getElementById('temperature-minmax');
      if (!iconEl || !dayEl || !mmEl) return;

      if (!day || typeof day !== 'object') {
        dayEl.textContent = '';
        mmEl.textContent = '';
        return; // keep existing icon
      }

      const label = typeof day.label === 'string' ? day.label : '';
      const maxVal = (typeof day.max === 'number') ? day.max : null;
      const minVal = (typeof day.min === 'number') ? day.min : null;
      const iconUrl = (typeof day.iconUrl === 'string' && day.iconUrl.trim()) ? day.iconUrl.trim() : '';
      const iconClasses = (typeof day.icon === 'string' && day.icon.trim()) ? day.icon.trim() : '';

      // set text
      dayEl.textContent = label || '';
      let mm = '';
      if (maxVal !== null && minVal !== null) {
        const lo = Math.min(minVal, maxVal);
        const hi = Math.max(minVal, maxVal);
        mm = `${lo}°-${hi}°`;
      } else if (maxVal !== null) {
        mm = `${maxVal}°`;
      } else if (minVal !== null) {
        mm = `${minVal}°`;
      }
      mmEl.textContent = mm;

      

      scheduleLeftStackScale();
    }

    function requestInitial() {
      try {
        // Fordert den aktuellen Zustand vom Modul an
        requestAction('GetState', 0);
      } catch (e) {
        console.error(e);
      }
    }

    window.addEventListener('resize', scheduleLeftStackScale);
    window.addEventListener('resize', () => {
      // Allow smooth live scaling during resize by removing inline font-size
      try {
        const clockContainer = document.getElementById('clock');
        const el = clockContainer ? (clockContainer.classList.contains('flip-clock') ? clockContainer : clockContainer.querySelector('.flip-clock')) : null;
        if (el && el.style) {
          el.style.removeProperty('font-size');
          el.style.removeProperty('width');
          el.style.removeProperty('min-width');
          el.style.removeProperty('max-width');
        }
      } catch (_) {}
      if (resizeDebounceTimer) {
        clearTimeout(resizeDebounceTimer);
      }
      resizeDebounceTimer = setTimeout(() => {
        resizeDebounceTimer = null;
        inWindowResize = true;
        scheduleResizeClock();
        inWindowResize = false;
      }, 150);
    });

    document.addEventListener('DOMContentLoaded', () => {
      requestInitial();
      initClock();
      applyClockVertical();
      scheduleLeftStackScale();
      scheduleResizeClock({ force: true });
    });
  </script>
</head>
<body>
  <div id="wrap">
    <div id="bgA" class="bg-layer is-active"></div>
    <div id="bgB" class="bg-layer"></div>
    <div id="left-stack">
      <div id="temperature">
        <span id="temperature-icon"></span>
        <span id="temperature-value"></span>
        <div id="temperature-extra">
          <div id="temperature-day"></div>
          <div id="temperature-minmax"></div>
        </div>
      </div>
      <div id="forecast" aria-label="3-Tage-Vorhersage"></div>
    </div>
    <img id="img" alt="" />
    <div id="clock-wrapper">
      <div id="clock"></div>
      <div id="date"></div>

    </div>
  </div>
  <div id="error"></div>

</body>
</html>
